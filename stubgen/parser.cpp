#include <iostream>
#include <fstream>
#include <map>
#include <regex>
#include <boost/algorithm/string.hpp>
#include <boost/format.hpp>

#include "parser.h"

const std::string PROG_BEGIN_PATTERN(R"(\s*program\s+(\w[\w\d]*)\s*[{]\s*)");
const std::string PROG_END_PATTERN(R"(\s*[}]\s*=\s*(0x|.*\d+);\s*)");
const std::string VERSION_BEGIN_PATTERN(R"(\s*version\s+(\w[\w\d]*)\s*[{]\s*)");
const std::string VERSION_END_PATTERN(R"(\s*[}]\s*=\s*(0x|.*\d+);\s*)");
const std::string SIGNATURE_PATTERN(R"(\s*(\w[\w\d ]*?\s*\*?)\s*(\w[\w\d]*)\s*\(\s*(\w[\w\d ]*\s*\*?)\)\s*=\s*(0x|.*\d+);\s*)");

StubGenerator::StubGenerator() :
        typeDictionary{{"string", "char *"},
                       {"short", "short"},
                       {"unsigned short", "unsigned short"},
                       {"int", "int"},
                       {"unsigned int", "unsigned int"},
                       {"long", "long"},
                       {"unsigned long", "unsigned long"},
                       {"float", "float"},
                       {"double", "double"},
                       {"bool", "bool_t"},
                       {"void", "void"},
        }
{}

void StubGenerator::parse(std::string &xFileName) {

    auto xFile = std::ifstream(xFileName);

    if(!xFile.is_open()) {
        std::cerr << "Cannot open file: " << xFileName << std::endl;
        exit(1);
    }

    auto content = readContent(xFile);
    auto strings = getSignificantStrings(content, '\n');

    std::string program;
    std::string prog_version;
    std::vector<version> versions;

    extractChunks(strings, program, prog_version, versions);

    auto fileName = xFileName.substr(0, xFileName.length() - 2);
    generateHfile(fileName, program, prog_version, versions);
    generateCppClientFile(fileName, prog_version, versions);
    generateCppServerFile(fileName, program, versions);

    xFile.close();
}

std::cmatch StubGenerator::match(std::string &string, const std::string &expression) const {
    std::__cxx11::regex e(expression);
    std::__cxx11::cmatch m;
    regex_match(string.c_str(), m, e);
    return m;
}

std::string StubGenerator::readContent(std::ifstream &file) {
    std::string str;

    file.seekg(0, std::ios::end);
    str.reserve(static_cast<unsigned long>(file.tellg()));
    file.seekg(0, std::ios::beg);

    str.assign((std::istreambuf_iterator<char>(file)),
               std::istreambuf_iterator<char>());

    return str;
}

std::vector<std::string> StubGenerator::getSignificantStrings(const std::string &s, char sep) const {
    std::vector<std::string> args;
    std::istringstream ss {s};
    
    for (std::string arg; std::getline(ss, arg, sep); ) {
        args.push_back(arg);
    }

    args.erase(
            std::remove_if(
                    args.begin(),
                    args.end(),
                    [](std::string const& s) { return s.empty(); }),
            args.end());

    for(auto &str: args){
        boost::trim(str);
    }

    return args;
}

void StubGenerator::extractChunks(std::vector<std::string> &strings,
                                  std::string &program,
                                  std::string &programVersion,
                                  std::vector<version> &versions) const {
    auto iter_strings = strings.begin();

    auto matches = this->match(*iter_strings++, PROG_BEGIN_PATTERN);
    if(matches.empty()) throw ParseException();
    program = matches[1];
    while(true) {
        matches = this->match(*iter_strings, VERSION_BEGIN_PATTERN);
        if (matches.empty()) break;
        else {
            versions.emplace_back();
            iter_strings++;
        }
        versions.back().name = matches[1];

        while(true) {
            matches = this->match(*iter_strings, SIGNATURE_PATTERN);
            if (matches.empty()) break;
            else iter_strings++;
            versions.back().functions.emplace_back(matches[1],
                                                   matches[2],
                                                   matches[3],
                                                   matches[4]);
        }

        matches = this->match(*iter_strings, VERSION_END_PATTERN);
        if (matches.empty()) break;
        else iter_strings++;
        versions.back().id = matches[1];
    }
    matches = this->match(*iter_strings++, PROG_END_PATTERN);
    if (matches.empty()) throw ParseException();
    programVersion = matches[1];
}

void StubGenerator::generateHfile(std::string &fileName,
                                  std::string &program,
                                  std::string &programVersion,
                                  std::vector<version> &versions) const {

    std::ofstream file(fileName + ".h");

    std::string content = "/*\n"
            " * Please do not edit this file.\n"
            " * It was generated using stubgen.\n"
            " */\n\n"
            "#ifndef _%s_H\n"
            "#define _%s_H\n"
            "#include <sys/socket.h>\n"
            "#include <sys/types.h>\n\n"
            "class ClientRPC;\n\n"
            "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#endif\n\n\n"
            "#define %s ((unsigned long) (%s))\n\n"
            "%s"
            "#ifdef __cplusplus\n"
            "}\n"
            "#endif\n\n"
            "#endif // _%s_H\n";

    std::string versionF = "#define %s ((unsigned long) (%s))\n"
            "char *%s_%s(unsigned long proc, void *argBuff, unsigned long *szResult);\n\n"
            "%s\n\n";

    std::string signatureF = "#define %s ((unsigned long) (%s))\n"
            "extern %s * %s_%s(%s *, ClientRPC *);\n"
            "extern %s * %s_%s_svc(%s *);\n";

    std::string versions_string;
    std::string signatures_string;
    std::string lower_progName = boost::algorithm::to_lower_copy(program);

    for(const auto &vers: versions) {
        for(const auto &func: vers.functions) {
            std::string lower_name = boost::algorithm::to_lower_copy(func.name);
            auto signature = (boost::format(signatureF)
                              % func.name % func.id
                              % getType(func.ret_type) % lower_name
                              % vers.id % getType(func.argument)
                              % getType(func.ret_type) % lower_name
                              % vers.id % getType(func.argument)).str();

            signatures_string.append(signature);
        }
        versions_string.append((boost::format(versionF)
                                % vers.name % vers.id
                                % boost::to_lower_copy(program) % vers.id
                                % signatures_string).str());
        signatures_string.clear();
    }

    std::string upper_fName = boost::algorithm::to_upper_copy(fileName.substr(3));
    std::string content_string((boost::format(content)
                                % upper_fName % upper_fName
                                % program % programVersion
                                % versions_string % upper_fName).str());

    file << content_string;
    file.close();
}

void StubGenerator::generateCppClientFile(std::string &fileName,
                                          std::string &prog_version,
                                          std::vector<StubGenerator::version> &versions) const {
    std::ofstream file(fileName + "_client.cpp");

    std::string contentF =
            "/*\n"
            " * Please do not edit this file.\n"
            " * It was generated using stubgen.\n"
            " */\n\n"
            "#include <memory.h>\n"
            "#include <sys/socket.h>\n"
            "#include \"client.h\"\n"
            "#include \"%s.h\"\n\n"
            "#define RECV_BUFFER_LENGTH ((unsigned long) (0x1000))\n"
            "%s";

    std::string functionF =
            "\n%s *%s_%s(%s* argp, ClientRPC *client) {\n"
            "    const char * message = nullptr;\n"
            "    char messageBuff[RECV_BUFFER_LENGTH];\n"
            "    send_message request{%s,\n"
            "                         %s,\n"
            "                         %s,\n"
            "                         sizeof(*argp),\n"
            "                         reinterpret_cast<char *>(argp)};\n\n"
            "    message = request.getSendMessage();\n\n"
            "    write(client->getSocketDescriptor(),\n"
            "          message,\n"
            "          sizeof(send_message) + request.szData);\n\n"
            "    delete message;\n"
            "    ssize_t receivedSize = 0;\n\n"
            "    receivedSize = read(client->getSocketDescriptor(),\n"
            "                        messageBuff,\n"
            "                        RECV_BUFFER_LENGTH);\n\n"
            "    if(receivedSize < 0) {\n"
            "        return nullptr;\n"
            "    }\n\n"
            "    receive_message answer{};\n"
            "    answer.readReceiveMessage(messageBuff);\n\n"
            "    if(answer.status == ERROR) {\n"
            "        return nullptr;\n"
            "    }\n"
            "\n"
            "    return reinterpret_cast<%s *>(answer.data);\n"
            "}\n";
    std::string file_string;
    std::string content_string;

    for(const auto &vers: versions) {
        for(const auto &func: vers.functions) {
            std::string lower_name = boost::algorithm::to_lower_copy(func.name);
            auto signature = (boost::format(functionF) % getType(func.ret_type)
                              % lower_name % vers.id % getType(func.argument)
                              % prog_version % vers.id % func.id
                              % getType(func.ret_type)).str();

            content_string.append(signature);
        }
    }

    file_string = (boost::format(contentF) % fileName % content_string).str();

    file << file_string;
    file.close();
}

void StubGenerator::generateCppServerFile(std::string &fileName,
                                          std::string &program,
                                          std::vector<StubGenerator::version> &versions) const {

    std::ofstream file(fileName + "_server.cpp");

    std::string contentF =
            "/*\n"
            "* This is sample code generated by stubgen.\n"
            " * These are only templates and you can use them\n"
            " * as a guideline for developing your own functions.\n"
            " */\n\n"
            "#include \"%s.h\"\n\n"
            "%s";

    std::string functionF =
            "\nchar *"
            "%s_%s(unsigned long proc, void *argBuff, unsigned long *szResult)\n"
            "{\n"
            "    char *(*local)(char *);\n"
            "    union {\n"
            "%s"
            "    } argument{};\n\n"
            "    switch (proc) {\n"
            "%s"
            "        default:\n"
            "            return nullptr;\n"
            "}\n"
            "    auto result = (*local)(reinterpret_cast<char*>(&argument));\n"
            "    return result;\n"
            "}\n\n"
            "%s";

    std::string argumentF =
            "        %s %s_%s_arg;\n";

    std::string caseF =
            "        case %s:\n"
            "            argument.%s_%s_arg = *static_cast<%s *>(argBuff);\n"
            "            *szResult = sizeof(%s);\n"
            "            local = (char *(*)(char *)) %s_%s_svc;\n"
            "            break;\n\n";

    std::string func_realizF =
            "\n%s *"
            "%s_%s_svc(%s *argp)\n"
            "{\n"
            "    static %s result;\n\n"
            "    /*\n"
            "     * insert server code here\n"
            "     */\n\n"
            "    return &result;\n"
            "}\n";

    std::string file_string;
    std::string content_string;
    std::string arguments;
    std::string case_string;
    std::string realizations;

    for(const auto &vers: versions) {
        for(const auto &func: vers.functions) {
            std::string lower_name = boost::algorithm::to_lower_copy(func.name);

            auto block1 = (boost::format(argumentF)
                           % getType(func.argument)
                           % boost::to_lower_copy(func.name) % vers.id).str();

            auto block2 = (boost::format(caseF)
                           % func.name
                           % boost::to_lower_copy(func.name) % vers.id
                           % getType(func.argument)
                           % getType(func.ret_type)
                           % boost::to_lower_copy(func.name) % vers.id).str();

            auto block3 = (boost::format(func_realizF)
                           % getType(func.ret_type)
                           % boost::to_lower_copy(func.name) % vers.id
                           % getType(func.argument) % getType(func.ret_type)).str();

            arguments.append(block1);
            case_string.append(block2);
            realizations.append(block3);
        }
        auto function = (boost::format(functionF)
                         % boost::to_lower_copy(program) % vers.id
                         % arguments % case_string % realizations).str();
        content_string.append(function);
        case_string.clear();
        realizations.clear();
        arguments.clear();
    }

    file_string = (boost::format(contentF) % fileName % content_string).str();

    file << file_string;
    file.close();
}

std::string StubGenerator::getType(std::string arg) const {
    if('*' == arg.back()) {
        arg = arg.substr(0, arg.length() - 1);
    }
    boost::trim(arg);
    return typeDictionary.at(arg);
}
