/*
* This is sample code generated by stubgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <iostream>
#include <memory.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <netinet/in.h>
#include <rpc/pmap_clnt.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <spdlog/logger.h>
#include "maths.h"

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

using SpdLogger = std::shared_ptr<spdlog::logger>;
extern SpdLogger logger;

void
math_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
    union {
            bool_t rexp_1_arg;
            long rpow_1_arg;
            long rfunc_1_arg;
    } argument{};
    char *result;

char ip[ INET_ADDRSTRLEN ];
inet_ntop( AF_INET, &transp->xp_raddr, ip, INET_ADDRSTRLEN );
logger->info("received request from " + std::string(ip)
             + ": v.1-f." + std::to_string(rqstp->rq_proc));

    xdrproc_t _xdr_argument, _xdr_result;
    char *(*local)(char *, struct svc_req *);

    switch (rqstp->rq_proc) {
    case NULLPROC:
            (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)nullptr);
            return;

        case SQR:
                _xdr_argument = (xdrproc_t) xdr_float;
                _xdr_result = (xdrproc_t) xdr_int;
                local = (char *(*)(char *, struct svc_req *)) sqr_1_svc;
                break;

        case EXP:
                _xdr_argument = (xdrproc_t) xdr_float;
                _xdr_result = (xdrproc_t) xdr_int;
                local = (char *(*)(char *, struct svc_req *)) exp_1_svc;
                break;

        case LOG10:
                _xdr_argument = (xdrproc_t) xdr_float;
                _xdr_result = (xdrproc_t) xdr_int;
                local = (char *(*)(char *, struct svc_req *)) log10_1_svc;
                break;

    default:
            svcerr_noproc (transp);
            return;
}
    memset ((char *)&argument, 0, sizeof (argument));
    if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
            svcerr_decode (transp);
            return;
    }
    result = (*local)((char *)&argument, rqstp);
    if (result != nullptr && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
            svcerr_systemerr (transp);
    }
    if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
            std::cerr << "unable to free arguments" << std::endl;
            exit (1);
    }
}


float *
sqr_1_svc(float *argp, struct svc_req *rqstp)
{
    static float result;

    /*
     * insert server code here
     */

    return &result;
}

float *
exp_1_svc(float *argp, struct svc_req *rqstp)
{
    static float result;

    /*
     * insert server code here
     */

    return &result;
}

float *
log10_1_svc(float *argp, struct svc_req *rqstp)
{
    static float result;

    /*
     * insert server code here
     */

    return &result;
}

void
math_prog_2(struct svc_req *rqstp, register SVCXPRT *transp)
{
    union {
            bool_t rexp_1_arg;
            long rpow_1_arg;
            long rfunc_1_arg;
    } argument{};
    char *result;

char ip[ INET_ADDRSTRLEN ];
inet_ntop( AF_INET, &transp->xp_raddr, ip, INET_ADDRSTRLEN );
logger->info("received request from " + std::string(ip)
             + ": v.2-f." + std::to_string(rqstp->rq_proc));

    xdrproc_t _xdr_argument, _xdr_result;
    char *(*local)(char *, struct svc_req *);

    switch (rqstp->rq_proc) {
    case NULLPROC:
            (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)nullptr);
            return;

        case SQR:
                _xdr_argument = (xdrproc_t) xdr_float;
                _xdr_result = (xdrproc_t) xdr_int;
                local = (char *(*)(char *, struct svc_req *)) sqr_2_svc;
                break;

        case EXP:
                _xdr_argument = (xdrproc_t) xdr_float;
                _xdr_result = (xdrproc_t) xdr_int;
                local = (char *(*)(char *, struct svc_req *)) exp_2_svc;
                break;

        case LOG10:
                _xdr_argument = (xdrproc_t) xdr_float;
                _xdr_result = (xdrproc_t) xdr_int;
                local = (char *(*)(char *, struct svc_req *)) log10_2_svc;
                break;

        case ABS:
                _xdr_argument = (xdrproc_t) xdr_float;
                _xdr_result = (xdrproc_t) xdr_int;
                local = (char *(*)(char *, struct svc_req *)) abs_2_svc;
                break;

    default:
            svcerr_noproc (transp);
            return;
}
    memset ((char *)&argument, 0, sizeof (argument));
    if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
            svcerr_decode (transp);
            return;
    }
    result = (*local)((char *)&argument, rqstp);
    if (result != nullptr && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
            svcerr_systemerr (transp);
    }
    if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
            std::cerr << "unable to free arguments" << std::endl;
            exit (1);
    }
}


float *
sqr_2_svc(float *argp, struct svc_req *rqstp)
{
    static float result;

    /*
     * insert server code here
     */

    return &result;
}

float *
exp_2_svc(float *argp, struct svc_req *rqstp)
{
    static float result;

    /*
     * insert server code here
     */

    return &result;
}

float *
log10_2_svc(float *argp, struct svc_req *rqstp)
{
    static float result;

    /*
     * insert server code here
     */

    return &result;
}

float *
abs_2_svc(float *argp, struct svc_req *rqstp)
{
    static float result;

    /*
     * insert server code here
     */

    return &result;
}
